<template>    <div class="wrapper-notes" :id="redactId">        <div class="notes-text-div" >            <span v-show="statusRedact">Redact</span>            <h3 class="notes-text__header notes__contentEdit"   @blur="endInputHeader($event)">{{txtHeader}}</h3>            <ul class="notes-ul__txt">                <li v-for="(txts,index) in Texts" class="notes-li__txt notes-li__txt-red"   @blur="endInput($event)" >                    <p class="paragraph notes-txt__width notes__contentEdit" :index="index" @blur="endInput($event.target)" @click="getThrough($event.target)">{{txts}}</p>                    <img @click="deleteNotes($event.target)" src="../img/trash.svg" alt="" class="trash-svg" :index="index">                </li>            </ul>            <input class="notes-input"  v-model="txt" v-show="showInput"                   @blur="end">        </div>        <div class="redact-button-wrapper">            <button class="redact-button-arrow" ><img class="redact-button-arrrow-img" src="../img/back-arrow.png" @click="back" alt=""></button>        <button class="redact-button-notes" @click="Create">Add</button>        <button class="redact-button-notes" @click="Edit"> Edit</button>        <button class="redact-button-notes" @click="save">Save </button>        </div>    </div>    </template><script>    export default {        data() {            return {                txt: '',                txtHeader: '',                showInput:false,                statusRedact:false,                Texts: [],                index: [],                id: '',                redactId: 'redactNot-',                redact: false,                readyEvent: false,                closedWindow: '',                lastAction: '',                lastTexts: '',                lastIndex: [],                i: '',            }        },        methods:{            Create(){                this.showInput = true            },            getLineThrougElem(){                    let notesId = document.getElementById(this.redactId)                    let elem = notesId.querySelectorAll('.paragraph')                    this.index.forEach(i => {                        elem[i].classList.add('lineThroug')                        console.log(elem[i].classList)                    })            },            getThrough(el) {                if (this.redact !== true) {                    this.lastAction = 'redactStatus'                    if (!el.classList.contains('lineThroug')) {                        el.classList.add('lineThroug')                        this.index.push(+el.attributes.index.value)                        this.lastAction = 'pop'                    } else {                        el.classList.remove('lineThroug')                        this.index = this.index.filter(elem => +elem !== +el.attributes.index.value)                    }                } else {                    return                }            },           async save(){               this.closedWindow = ''               this.readyEvent = false                this.$route.params.index = this.index                this.$route.params.id = this.id                history.back()                this.$emit('redactnotes')            },            endInputHeader(e){                this.txtHeader = e.currentTarget.textContent;                this.$set(this.txtHeader,e.textContent)            },            async  endInput(e) {                this.lastAction= 'edit'                let index = +e.attributes.index.value                this.lastTexts = this.Texts[index]                    this.i = index                let redactText = e.textContent                this.Texts.splice(index,1,redactText)            },            end(){                this.Texts.push(this.txt);                this.txt = null;                this.showInput = false            },            async back(e) {                let notesId = document.getElementById(this.redactId);                let elem = notesId.querySelectorAll('.paragraph');                if (this.lastAction === 'edit') {                    this.Texts.splice(this.i, 1, this.lastTexts)                    elem[this.i].textContent = this.lastTexts                } else if (this.lastAction === 'redactStatus') {                    this.index = this.lastIndex                    this.getLineThrougElem()                } else if (this.lastAction === 'pop') {                  let pops = this.index.pop()                    elem.forEach(el => {                        let i = +el.attributes.index.value                        el.classList.remove('lineThroug')                    });                    this.getLineThrougElem()                    this.lastIndex.push(pops)                } else if (this.lastAction === 'delete') {                    await this.Texts.splice(this.i, 0, this.lastTexts)                    elem = notesId.querySelectorAll('.paragraph');                    this.index = this.lastIndex                    //удаляем класс LineThroug, задаем заметкам правильные наименования в соотвествии с массивом this.Texts                    elem.forEach(el => {                        let i = +el.attributes.index.value                        el.classList.remove('lineThroug')                        el.textContent = this.Texts[i]                    });                    this.getLineThrougElem()                }            },            /**             * Метод присваивает всем элементам массива contentEditable или же убирает в завимости от redact             * @oaram redact {boolean} -статус редактирования.             * @param statusRedact {boolean} - if true - отображает элемент директивой v-show             */            Edit(){                let notesId = document.getElementById(this.redactId)                let elem = notesId.querySelectorAll('.paragraph')                this.redact = !this.redact;                if(this.redact === true){                    this.statusRedact = true                    elem.forEach(el =>{                        el.contentEditable = true                    })                } else {                    this.statusRedact = false                    let current = 0                    elem.forEach(el =>{                        el.contentEditable = false                    })                }            },            /**             *             *             * @param el {DOM element} - элемент по которому был совершен клик             * @param elem {array} - массив редактируемых заметок             * @param iElem {string} - значение удаляемой заметки             * @param this.i {number} - индекс удаляемой заметки, её место в общем массиве This.Texts             * @returns {Promise<void>}             *             *             */            async  deleteNotes(el){                this.lastAction = 'delete'                let i = +el.attributes.index.value;                let notesId = document.getElementById(this.redactId);                let elem = notesId.querySelectorAll('.paragraph');                let iElem = this.Texts[i]                await  this.Texts.splice(i, 1);                //сохраняем данные для отмены изменений                this.lastTexts = iElem                this.lastIndex = this.index                this.i = i                // если в массиве index был индекс удаленного элемента метод filer его удалит                this.index = this.index.filter(elem => +elem !== +el.attributes.index.value);                let newIndex = this.index.map(num => {                    if (+num > i) {                        return num - 1                    } else if (+num <= i) {                        return +num                    }                })                this.index = newIndex;                //удаляем класс LineThroug, задаем заметкам правильные наименования в соотвествии с массивом this.Texts                elem.forEach(el => {                    let i = +el.attributes.index.value                    el.classList.remove('lineThroug')                    el.textContent = this.Texts[i]                })                this.getLineThrougElem()            }        },        async mounted(){             await this.getLineThrougElem()            //при клипе вне элемента div закрываем заметку           let closed = ()=> {               document.addEventListener('click', (event) => {                   console.log("вызвано")                   let redactDiv = document.getElementById(this.redactId)                 if (!redactDiv.contains(event.target) && this.readyEvent === true && !event.target.classList.contains('trash-svg') ) {                       document.removeEventListener('click', this.closedWindow)                       this.readyEvent = false                       this.save()                   } else {                       this.readyEvent = true                   }               })           }            this.closedWindow = closed;            closed()        },        /**         * @event {$emit} -пользовательское событие для получения актуального index         * @param this.index{array} -массив содержит index пунктов блокнота помеченных как выполненные         */        created() {                this.id = this.$route.params.id                this.$emit('newIndex')                this.txtHeader = this.$route.params.head;                this.Texts = this.$route.params.Text                this.index = this.$route.params.index                this.redactId = this.redactId + this.id        }    }</script><style scoped>    .notes-text-div{        width: 80%;        display: flex;        flex-direction: column;        align-items: center;    }    .wrapper-notes{        width: 30%;        left: 35%;        top:50%;        padding: 20px;        border-radius: 15px;    }    .trash-svg{        width: 20px;        align-items: flex-end;    }    .notes-li__txt{        display: flex;    }    .notes-input{        width: 100%;        margin-bottom: 10px;        border:1px solid  #6495ed;    }    .notes-ul__txt{        width: 80%;        display: flex;        flex-direction: column;    }    .notes-txt__width {        width: 100%;    }    .redact-button-wrapper{        display: flex;        flex-basis: 33%;    }    .redact-button-notes{        margin-left: 5%;    }    .redact-button-arrow{        background: none;        width: 25px;        outline: 0!important;        border: none;    }    .redact-button-arrrow-img{        width: 15px;    }</style>