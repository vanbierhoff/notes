<template>    <div class="wrapper-notes" :id="redactId" v-bind:class="{redactNotes:statusRedact}">        <div class="notes-text-div">            <router-link :to="{path:'/'}" class="redact-button-save" >back</router-link>            <span v-show="statusRedact" class="status-redact">Redact</span>            <div class="redact-button-wrapper">                <button class="redact-button-arrow"><img class="redact-button-arrrow-img" src="../img/back-arrow.png"                                                         @click="back" alt=""></button>                <button class="redact-button-notes" @click="Create">Add</button>                <button class="redact-button-notes" @click="Edit"> Edit</button>                <button class=" redact-button-notes" @click="save"> save</button>            </div>            <input class="notes-input" v-model="txt" v-show="showInput"                   @blur="end">            <h3 class="notes-text__header notes__contentEdit" v-for="head in txtHeader" @blur="endInputHeader($event)">                {{head}}</h3>            <ul class="notes-ul__txt">                <li v-for="(txts,index) in Texts" class="notes-li__txt notes-li__txt-red">                    <p class="paragraph notes-txt__width notes__contentEdit" :index="index"                       @blur="endInput($event.target)" @click="getThrough($event.target)">{{txts}}</p>                    <img @click="deleteNotes($event.target)" src="../img/trash.svg" alt="" class="trash-svg"                         :index="index">                </li>            </ul>            <button class="cancel-all" @click="cancelAll">Cancel all</button>        </div>    </div></template><script>    export default {        data() {            return {                txt: '',                txtHeader: [],                showInput: false,                statusRedact: false,                Texts: [],                index: [],                id: '',                redactId: 'redactNot-',                redact: false,                readyEvent: false,                closedWindow: '',                // группа data для работы с отменой измененмий                lastAction: '',                   // последнее действие с заметкой                lastTexts: '',                    // последний иземенный текст                lastIndex: [],                    // массив индексов до измнений                i: '',                            // порядковый номер в массиве index                reverse: true,                    //  идентификатор для отмены изменений                reverseTxtEdit: '',               // Значение последней измененный заметки до её изменения                reverseCheck: '',                 // идентификатор для отмены изменений                popIndex: '',                     // последнмй измененный индекс                reverseHeadEdit: '',               // Значение заголовка до его изменения                cancelTexts: [],                cancelIndex: [],                cancelHead: [],                removeEvent: false,                linkPoint: true,            }        },        methods: {            Create() {                this.showInput = true            },            getLineThrougElem() {                let notesId = document.getElementById(this.redactId)                let elem = notesId.querySelectorAll('.paragraph')                this.index.forEach(i => {                    elem[i].classList.add('lineThroug')                    console.log(elem[i].classList)                })            },            getThrough(el) {                if (this.redact !== true) {   //если в данный момент включено редактирование текста, выполнение tоdo не отмечается                    this.lastAction = 'redactStatus'                    this.lastIndex = this.index                    if (!el.classList.contains('lineThroug')) {                        el.classList.add('lineThroug')                        this.index.push(+el.attributes.index.value)                        this.reverseCheck = true                    } else {                        el.classList.remove('lineThroug')                        this.index.forEach((elem,index)=> {                            if(+elem === +el.attributes.index.value){                                this.index.splice(index,1)                            }                        })                        this.popIndex = +el.attributes.index.value                        this.reverseCheck = false                    }                } else {                    return                }            },            async save() {                if(this.removeEvent === false){                    document.removeEventListener('click', this.closedWindow)                }                this.readyEvent = false                this.$route.params.ind = this.index                this.$route.params.id = this.id                this.$route.params.Text = this.Texts                this.$route.params.head = this.txtHeader                this.$emit('redactnotes')            },            endInputHeader(e) {                this.reverse = true                this.lastAction = 'editHeader'                this.lastTexts = this.txtHeader[0]                this.txtHeader.splice(0, 1, e.target.textContent);                this.reverseHeadEdit = e.target.textContent            },            async endInput(e) {                this.reverse = true                this.lastAction = 'edit'                let index = +e.attributes.index.value                this.lastTexts = this.Texts[index]                this.i = index                let redactText = e.textContent                this.reverseTxtEdit = redactText                this.Texts.splice(index, 1, redactText)            },            end() {                this.lastAction = 'add'                this.reverse = true                this.Texts.push(this.txt);                this.lastTexts = this.txt                this.txt = null;                this.showInput = false            },            async back() {                let notesId = document.getElementById(this.redactId);                let elem = notesId.querySelectorAll('.paragraph');                let eheader = notesId.querySelector('.notes-text__header')                switch (this.lastAction) {                    case 'edit' :                        if (this.reverse) {                            this.Texts.splice(this.i, 1, this.lastTexts)                            elem[this.i].textContent = this.lastTexts                            this.reverse = false                        } else {                            this.Texts.splice(this.i, 1, this.reverseTxtEdit)                            elem[this.i].textContent = this.reverseTxtEdit                            this.reverse = true                        }                        break                    case 'redactStatus':                        elem.forEach(el => {                            let i = +el.attributes.index.value                            el.classList.remove('lineThroug')                        });                        if (this.reverseCheck) {                            this.popIndex = this.index.pop()                            this.reverseCheck = false                        } else {                            this.index.push(this.popIndex)                            this.reverseCheck = true                        }                        this.getLineThrougElem()                        break                    case 'delete':                        if (this.reverse) {                            await this.Texts.splice(this.i, 0, this.lastTexts)                            this.reverse = false                        } else {                            await this.Texts.splice(this.i, 1)                            this.reverse = true                        }                        elem = notesId.querySelectorAll('.paragraph');                        this.index = this.lastIndex                        //удаляем класс LineThroug, задаем заметкам правильные наименования в соотвествии с массивом this.Texts                        elem.forEach(el => {                            let i = +el.attributes.index.value                            el.classList.remove('lineThroug')                            el.textContent = this.Texts[i]                        });                        this.getLineThrougElem()                        break                    case 'editHeader':                        if (this.reverse) {                            this.txtHeader.splice(0, 1, this.lastTexts)                            eheader.textContent = this.txtHeader[0]                            this.reverse = false                        } else {                            this.txtHeader.splice(0, 1, this.reverseHeadEdit)                            eheader.textContent = this.txtHeader[0]                            this.reverse = true                        }                        break                    case 'add':                        if (this.reverse) {                            this.Texts.pop()                            this.reverse = false                        } else {                            this.Texts.push(this.lastTexts)                            this.reverse = true                        }                }            },            /**             * Метод присваивает всем элементам массива contentEditable или же убирает в завимости от redact             * @oaram redact {boolean} -статус редактирования.             * @param statusRedact {boolean} - if true - отображает элемент директивой v-show             */            Edit() {                let notesId = document.getElementById(this.redactId)                let elem = notesId.querySelectorAll('.notes__contentEdit')                this.redact = !this.redact;                if (this.redact === true) {                    this.statusRedact = true                    elem.forEach(el => {                        el.contentEditable = true                    })                } else {                    this.statusRedact = false                    let current = 0                    elem.forEach(el => {                        el.contentEditable = false                    })                }            },            /**             *             *             * @param el {DOM element} - элемент по которому был совершен клик             * @param elem {array} - массив редактируемых заметок             * @param iElem {string} - значение удаляемой заметки             * @param this.i {number} - индекс удаляемой заметки, её место в общем массиве This.Texts             * @returns {Promise<void>}             *             *             */            async deleteNotes(el) {                this.lastAction = 'delete'                this.reverse = true                let i = +el.attributes.index.value;                let notesId = document.getElementById(this.redactId);                let elem = notesId.querySelectorAll('.paragraph');                let iElem = this.Texts[i]                await this.Texts.splice(i, 1);                //сохраняем данные для отмены изменений                this.lastTexts = iElem                this.lastIndex = this.index                this.i = i                // если в массиве index был индекс удаленного элемента метод filer его удалит                this.index.forEach((elem, i)=>{                    if(+elem === +el.attributes.index.value){                        this.index.splice(i,1)                    }                })                let newIndex = this.index.map(num => {                    if (+num > i) {                        return num - 1                    } else if (+num <= i) {                        return +num                    }                })                this.index = newIndex;                //удаляем класс LineThroug, задаем заметкам правильные наименования в соотвествии с массивом Texts                elem.forEach(el => {                    let i = +el.attributes.index.value                    el.classList.remove('lineThroug')                    el.textContent = this.Texts[i]                })                this.getLineThrougElem()            },            async cancelAll() {                let cancel = JSON.parse(localStorage.cancel)                let notesId = document.getElementById(this.redactId);                let elem = notesId.querySelectorAll('.paragraph');                this.txtHeader.splice(0, 1, cancel.head[0])                this.index = cancel.index                let i = 0                let difference = null                cancel.texts.forEach(el => {                    this.Texts.splice(i, 1, cancel.texts[i])                    i++                })                // если отредактированный массив больше исходного, удаляем лишние элементы                if (this.Texts.length > cancel.texts.length) {                    difference = this.Texts.length - cancel.texts.length                    this.Texts.splice(i, difference)                }                //ждем отрисовки всех заметок                await this.Texts                elem.forEach(el => {                    let i = +el.attributes.index.value                    el.classList.remove('lineThroug')                    el.textContent = this.Texts[i]                })                this.getLineThrougElem()            },        },        async mounted() {            await this.getLineThrougElem()            //при клипе вне элемента div закрываем заметку               this.closedWindow =  (event) =>{                       console.log("вызвано")                       let redactDiv = document.getElementById(this.redactId)                       if (!redactDiv.contains(event.target) && this.readyEvent === true && !event.target.classList.contains('trash-svg'                        && event.target)) {                           document.removeEventListener('click', this.closedWindow)                           this.readyEvent = false                           this.removeEvent = true                           this.save()                       } else {                           this.readyEvent = true                       }               }               document.addEventListener('click', this.closedWindow)            },        /**         * @event {$emit} -пользовательское событие для получения актуального index         * @param  this.index{array} -массив содержит index пунктов блокнота помеченных как выполненные         */        created() {            this.id = this.$route.params.id            //this.$emit('newIndex')   // получаем массив index редактируемой заметки            this.txtHeader = this.$route.params.head;            this.Texts = this.$route.params.Text            this.index = this.$route.params.ind            this.redactId = this.redactId + this.id            this.$route.params.goLink = false            let head = this.$route.params.head            let index = this.$route.params.ind            let texts = this.$route.params.Text            //сохраняем в localStorage исходные данные для возможности отмены изменений            let cancel = {                head: this.$route.params.head,                index: this.$route.params.ind,                texts: this.$route.params.Text,            }            localStorage.cancel = JSON.stringify(cancel)        }    }</script><style scoped>    .status-redact {        align-self: flex-end;        color: #32CD32;        position: absolute;    }    .notes-text-div {        width: 80%;        display: flex;        flex-direction: column;        align-items: center;    }    .wrapper-notes {        width: 30%;        left: 35%;        top: 50%;        padding: 20px;        border-radius: 15px;        border: 1px solid #000080;    }    .trash-svg {        width: 20px;        align-items: flex-end;    }    .notes-li__txt {        display: flex;    }    .notes-input {        width: 100%;        margin-top: 10px;        border: 1px solid #6495ed;    }    .notes-ul__txt {        width: 80%;        display: flex;        flex-direction: column;    }    .notes-txt__width {        width: 100%;    }    .redact-button-save{        align-self: flex-start;    }    .redact-button-wrapper {        display: flex;        justify-content: center;        flex-basis: 33%;    }    .redact-button-notes {        margin-left: 5%;    }    .redact-button-arrow {        background: none;        width: 25px;        outline: 0 !important;        border: none;    }    .redact-button-arrrow-img {        width: 15px;    }</style>